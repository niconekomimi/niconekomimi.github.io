{"meta":{"title":"NecoMiMi","subtitle":"","description":"","author":"Evil_Eyes","url":"https://niconekomimi.github.io","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"04-08","excerpt":""},{"title":"about","text":"","path":"about/index.html","date":"05-01","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"04-09","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"04-09","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"04-08","excerpt":""},{"title":"search","text":"","path":"search/index-1.html","date":"04-08","excerpt":""}],"posts":[{"title":"","text":"打标签 labelimg images label&#x2F;classes.txt 训练模型 yolo task&#x3D;detect mode&#x3D;train data&#x3D;group3.yaml model&#x3D;yolov10n.pt epochs&#x3D;100 batch&#x3D;8 device&#x3D;0 imgsz&#x3D;640 patience&#x3D;50 augment&#x3D;True hsv_h&#x3D;0.5 hsv_s&#x3D;0.5 hsv_v&#x3D;0.5 degrees&#x3D;45 translate&#x3D;0.2 scale&#x3D;0.5 fliplr&#x3D;0.5 mosaic&#x3D;1.0 name&#x3D;group3_experiment 测试模型 yolo task&#x3D;detect mode&#x3D;predict conf&#x3D;0.25 save&#x3D;True model&#x3D;runs&#x2F;detect&#x2F;group3_experiment2&#x2F;weights&#x2F;best.pt source&#x3D;test_images\\test_images_3\\image.JPG python generate_boxes.py –image datasets\\group3\\images\\val\\image.JPG –class-name “bottle” –confidence 0.88 –label-file datasets\\group3\\labels\\val\\image.txt","path":"2025/05/20/yolo/","date":"05-20","excerpt":"","tags":[]},{"title":"","text":"启动服务 1roslaunch robotiq_2f_gripper_control robotiq_action_server.launch sim:=false comport:=&quot;/dev/ttyUSB0&quot; stroke:=0.140 baud:=115200 启动夹爪可视化界面 123roslaunch robotiq_2f_gripper_control test_140mm_gripper.launch \\ sim:=false \\ comport:=&quot;/dev/ttyUSB0&quot; 控制代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# -*- coding: utf-8 -*-#!/usr/bin/env python2import rospyimport actionlibimport sysimport ttyimport termiosfrom threading import Threadfrom robotiq_2f_gripper_msgs.msg import CommandRobotiqGripperAction, CommandRobotiqGripperGoalclass RobotiqGripperController: def __init__(self, action_name=&#x27;command_robotiq_action&#x27;): self.client = actionlib.SimpleActionClient(action_name, CommandRobotiqGripperAction) self.timeout = rospy.Duration(10.0) if not self.client.wait_for_server(rospy.Duration(5.0)): rospy.logerr(&quot;无法连接Action Server！请检查节点是否启动&quot;) sys.exit(1) def control_gripper(self, position, speed=0.1, force=50.0): &quot;&quot;&quot;非阻塞控制夹爪&quot;&quot;&quot; position = max(0.0, min(position, 0.140)) speed = max(0.01, min(speed, 0.1)) force = max(0.0, min(force, 100.0)) goal = CommandRobotiqGripperGoal() goal.emergency_release = False goal.stop = False goal.position = float(position) goal.speed = float(speed) goal.force = float(force) self.client.send_goal(goal)def get_key(): &quot;&quot;&quot;非阻塞读取单个按键&quot;&quot;&quot; fd = sys.stdin.fileno() old_settings = termios.tcgetattr(fd) try: tty.setraw(sys.stdin.fileno()) ch = sys.stdin.read(1) finally: termios.tcsetattr(fd, termios.TCSADRAIN, old_settings) return chdef key_listener(gripper): &quot;&quot;&quot;按键监听线程&quot;&quot;&quot; print(&quot;\\n按键控制说明：&quot;) print(&quot; [O] 打开夹爪&quot;) print(&quot; [C] 闭合夹爪&quot;) print(&quot; [Q] 退出程序&quot;) while not rospy.is_shutdown(): key = get_key().lower() if key == &#x27;o&#x27;: gripper.control_gripper(0.140, speed=0.1, force=30) print(&quot;夹爪已打开&quot;) elif key == &#x27;c&#x27;: gripper.control_gripper(0.0, speed=0.1, force=80) print(&quot;夹爪已闭合&quot;) elif key == &#x27;q&#x27;: rospy.signal_shutdown(&quot;用户退出&quot;) breakif __name__ == &#x27;__main__&#x27;: rospy.init_node(&#x27;robotiq_gripper_key_control&#x27;) gripper = RobotiqGripperController() # 启动按键监听线程 Thread(target=key_listener, args=(gripper,)).start() try: rospy.spin() # 保持节点运行 except rospy.ROSInterruptException: print(&quot;程序被中断&quot;)","path":"2025/05/20/夹爪控制/","date":"05-20","excerpt":"","tags":[]},{"title":"","text":"2 预备知识2.1 数据操作2.1.1 入门123456789101112131415161718192021222324252627282930313233import torchx = torch.arange(12) # 生成一个0-11的int64类型张量 结果为 tensor([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])# 如果要创建浮点型张量 x = torch.arange(12, dtype=torch.float32)x.shape# 通过张量的shape属性来访问张量（沿每个轴的长度）的形状 结果为 torch.Size([12])x.numel()# 张量中元素的总数 结果为 12#改变张量的形状y = x.reshape(3, 4)# tensor([[ 0, 1, 2, 3],# [ 4, 5, 6, 7],# [ 8, 9, 10, 11]])y.shape# 通过张量的shape属性来访问张量（沿每个轴的长度）的形状 结果为 torch.Size([3, 4])#多维张量创建#创建一个形状为(2, 3, 4)的张量，其中所有元素设置为0z = torch.zeros((2, 3, 4))#创建一个形状为(2, 3, 4)的张量，其中所有元素设置为1z = torch.noes((2, 3, 4))#有时我们想通过从某个特定的概率分布中随机采样来得到张量中每个元素的值。 例如，当我们构造数组来作为神经网络中的参数时，我们通常会随机初始化参数的值。 以下代码创建一个形状为（3,4）的张量。 其中的每个元素都从均值为0、标准差为1的标准高斯分布（正态分布）中随机采样。a = torch.randn(3, 4)# 结果可能为 tensor([[-0.0135, 0.0665, 0.0912, 0.3212],# [ 1.4653, 0.1843, -1.6995, -0.3036],# [ 1.7646, 1.0450, 0.2457, -0.7732]])#直接赋值创建张量b = torch.tensor([[2, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]]) 2.1.2 运算符123456789101112131415161718192021222324252627282930#两个张量加减乘除幂x = torch.tensor([1.0, 2, 4, 8])y = torch.tensor([2, 2, 2, 2])print(x + y)print(x - y)print(x * y)print(x / y)print(x ** y)#对每个元素处理e的元素值次方torch.exp(x)#多个张量的连结X = torch.arange(12, dtype=torch.float32).reshape((3,4))Y = torch.tensor([[2.0, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])#两张量保持列不变进行连结torch.cat((X, Y), dim=0)#两张量保持行不变进行连结torch.cat((X, Y), dim=1)#使用逻辑运算构建二元张量X == Y#当元素一样时填入true，不一样时填入false# tensor([[False, True, False, True],# [False, False, False, False],# [False, False, False, False]])#对张量中所有元素进行求和X.sum() 2.1.3 广播机制123456789101112a = torch.arange(3).reshape((3, 1))# tensor([[0],# [1],# [2]])b = torch.arange(2).reshape((1, 2))# tensor([[0, 1]]))#由于a和b分别是3*1和1*2矩阵，如果让它们相加，它们的形状不匹配。 我们将两个矩阵广播为一个更大的3*2矩阵，如下所示：矩阵a将复制列， 矩阵b将复制行，然后再按元素相加。a + b# tensor([[0, 1],# [1, 2],# [2, 3]]) 2.1.4 索引和切片12345678910111213141516171819202122X = torch.arange(0, 12).reshape(3, 4)#tensor([[ 0, 1, 2, 3],# [ 4, 5, 6, 7],# [ 8, 9, 10, 11]])print(X[-1])#结果为 tensor([ 8, 9, 10, 11])print(X[1:3])#结果为 tensor([[ 4, 5, 6, 7],# [ 8, 9, 10, 11]])# [-1]选择最后一个元素，可以用[1:3]选择第二个和第三个元素#给特定元素赋值X[1, 2] = 9print(X)#tensor([[ 0, 1, 2, 3],# [ 4, 5, 9, 7],# [ 8, 9, 10, 11]])#为多个元素赋值,[0:2, :]访问第1行和第2行，其中“:”代表沿轴1（列）的所有元素X[0:2, :] = 12print(X) 2.1.5 节省内存1234567# 可以看到 Y加上X之后内存地址变了，说明Y指向了新的内存地址。before = id(Y)Y = Y + Xid(Y) == before //falseX[:] = X + Y或X += Y# 可以减少操作的内存开销 2.1.6 转换为其他Python对象12345678910# 将深度学习框架定义的张量转换为NumPy张量（ndarray）很容易，反之也同样容易。 torch张量和numpy数组将共享它们的底层内存，就地操作更改一个张量也会同时更改另一个张量。A = X.numpy()B = torch.tensor(A)type(A) #numpy.ndarraytype(B) #torch.Tensor要将大小为1的张量转换为Python标量，我们可以调用item函数或Python的内置函数。a = torch.tensor([3.5])a, a.item(), float(a), int(a) #(tensor([3.5000]), 3.5, 3.5, 3) 2.2 数据预处理​ 为了能用深度学习来解决现实世界的问题，我们经常从预处理原始数据开始， 而不是从那些准备好的张量格式数据开始。 在Python中常用的数据分析工具中，我们通常使用pandas软件包。 像庞大的Python生态系统中的许多其他扩展包一样，pandas可以与张量兼容。 2.2.1 读取数据集123456789101112131415161718192021222324import osimport pandas as pd#创建路径 ../dataos.makedirs(os.path.join(&#x27;..&#x27;,&#x27;data&#x27;),exist_ok=True)#创建文件 ../data/house_tiny.csvdata_file = os.path.join(&#x27;..&#x27;,&#x27;data&#x27;,&#x27;house_tiny.csv&#x27;)#将数据逐行写入文件with open(data_file, &#x27;w&#x27;) as f: f.write(&#x27;NumRooms,Alley,Price\\n&#x27;) # 列名 f.write(&#x27;NA,Pave,127500\\n&#x27;) # 每行表示一个数据样本 f.write(&#x27;2,NA,106000\\n&#x27;) f.write(&#x27;4,NA,178100\\n&#x27;) f.write(&#x27;NA,NA,140000\\n&#x27;)#读取文件data = pd.read_csv(data_file)#打印文件print(data) # NumRooms Alley Price# 0 NaN Pave 127500# 1 2.0 NaN 106000# 2 4.0 NaN 178100# 3 NaN NaN 140000 2.2.3 处理缺失值​ “NaN”项代表缺失值。 为了处理缺失的数据，典型的方法包括插值法和删除法， 其中插值法用一个替代值弥补缺失值，而删除法则直接忽略缺失值。 在这里，我们将考虑插值法。 1234567891011121314151617181920# inputs为第一和第二行元素，output为第三行元素inputs, outputs = data.iloc[:, 0:2], data.iloc[:, 2]# fillna()将NaN替换为一个值，inputs.mean()计算每列的均值inputs = inputs.fillna(inputs.mean())print(inputs)# NumRooms Alley# 0 3.0 Pave# 1 2.0 NaN# 2 4.0 NaN# 3 3.0 NaN# 对类别型列（如 Alley）进行独热编码，并将 NaN 视为独立类别，如，Alley中有Pave和NaN，就将Pave和NaN分开inputs = pd.get_dummies(inputs, dummy_na=True)print(inputs)# NumRooms Alley_Pave Alley_nan# 0 3.0 1 0# 1 2.0 0 1# 2 4.0 0 1# 3 3.0 0 1 2.2.3转换为张量格式 1234567891011import torchX = torch.tensor(inputs.to_numpy(dtype=float))y = torch.tensor(outputs.to_numpy(dtype=float))print(x)print(y)# tensor([[3., 1., 0.],# [2., 0., 1.],# [4., 0., 1.],# [3., 0., 1.]], dtype=torch.float64)# tensor([127500., 106000., 178100., 140000.], dtype=torch.float64) 2.3 线性代数2.3.1 标量标量由只有一个元素的张量表示 123456789import torchx = torch.tensor(3.0)y = torch.tensor(2.0)print(x + y) # (tensor(5.)print(x * y) # tensor(6.)print(x / y) # tensor(1.5000)print(x ** y) # tensor(9.) 2.3.2 向量向量可以被视为标量值组成的列表。 这些标量值被称为向量的元素（element）或分量（component） 1x = torch.arange(4) # tensor([0, 1, 2, 3]) 2.3.2.1 长度、维度和形状我们可以通过调用Python的内置len()函数来访问张量的长度 12len(x) #4print(x.shape) #torch.Size([4]) 2.3.3. 矩阵12345678910111213141516171819202122A = torch.arange(20).reshape(5, 4)print(A)# tensor([[ 0, 1, 2, 3],# [ 4, 5, 6, 7],# [ 8, 9, 10, 11],# [12, 13, 14, 15],# [16, 17, 18, 19]])print(A.T)# tensor([[ 0, 4, 8, 12, 16],# [ 1, 5, 9, 13, 17],# [ 2, 6, 10, 14, 18],# [ 3, 7, 11, 15, 19]])#对于对称矩阵，B=B.TB = torch.tensor([[1, 2, 3], [2, 0, 4], [3, 4, 5]])print(B)print(B.T)print(B == B.T)# tensor([[True, True, True],# [True, True, True],# [True, True, True]]) 2.3.4. 张量​ 就像向量是标量的推广，矩阵是向量的推广一样，我们可以构建具有更多轴的数据结构。 张量（本小节中的“张量”指代数对象）是描述具有任意数量轴的(n)维数组的通用方法。例如，向量是一阶张量，矩阵是二阶张量。 123456789X = torch.arange(24).reshape(2, 3, 4)print(X)# tensor([[[ 0, 1, 2, 3],# [ 4, 5, 6, 7],# [ 8, 9, 10, 11]],# [[12, 13, 14, 15],# [16, 17, 18, 19],# [20, 21, 22, 23]]]) 2.3.5. 张量算法的基本性质12345678910111213141516A = torch.arange(20, dtype=torch.float32).reshape(5, 4)B = A.clone() # 通过分配新内存，将A的一个副本分配给BA = torch.arange(20, dtype=torch.float32).reshape(5, 4)B = A.clone() # 通过分配新内存，将A的一个副本分配给Bprint(A)print(A + B)# (tensor([[ 0., 1., 2., 3.],# [ 4., 5., 6., 7.],# [ 8., 9., 10., 11.],# [12., 13., 14., 15.],# [16., 17., 18., 19.]]),# tensor([[ 0., 2., 4., 6.],# [ 8., 10., 12., 14.],# [16., 18., 20., 22.],# [24., 26., 28., 30.],# [32., 34., 36., 38.]])) 具体而言，两个矩阵的按元素乘法称为Hadamard积（Hadamard product）（数学符号(\\odot)）。 对于矩阵(\\mathbf{B} \\in \\mathbb{R}^{m \\times n})， 其中第(i)行和第(j)列的元素是(b_{ij})。 矩阵(\\mathbf{A})（在 (2.3.2)中定义）和(\\mathbf{B})的Hadamard积为： (2.3.4)¶[\\begin{split}\\mathbf{A} \\odot \\mathbf{B} &#x3D; \\begin{bmatrix} a_{11} b_{11} &amp; a_{12} b_{12} &amp; \\dots &amp; a_{1n} b_{1n} \\ a_{21} b_{21} &amp; a_{22} b_{22} &amp; \\dots &amp; a_{2n} b_{2n} \\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\ a_{m1} b_{m1} &amp; a_{m2} b_{m2} &amp; \\dots &amp; a_{mn} b_{mn} \\end{bmatrix}.\\end{split}] 123456print(A * B)# tensor([[ 0., 1., 4., 9.],# [ 16., 25., 36., 49.],# [ 64., 81., 100., 121.],# [144., 169., 196., 225.],# [256., 289., 324., 361.]]) 3 线性神经网络1","path":"2025/05/06/深度学习/","date":"05-06","excerpt":"","tags":[]},{"title":"","text":"1 数组创建：1234567891011121314151617import numpy as np# 从列表创建数组a = np.array([1, 2, 3, 4])print(a) # [1 2 3 4]# 创建二维数组b = np.array([[1, 2, 3], [4, 5, 6]])print(b) # [[1 2 3]# [4 5 6]]# 创建特殊数组zeros = np.zeros((2, 3)) # 2x3的全0数组ones = np.ones((3, 2)) # 3x2的全1数组empty = np.empty((2, 2)) # 2x2的未初始化数组identity = np.eye(3) # 3x3的单位矩阵 2 数组操作：1234567891011121314151617181920# 获取数组形状/及数组是几列几行print(b.shape) # (2, 3)# 改变数组形状c = b.reshape(3, 2)print(c)# [[1 2]# [3 4]# [5 6]]# 数组切片print(a[0:2]) # [1 2]print(b[0, 1]) # 2# 数组转置d = b.Tprint(d)# [[1 4]# [2 5]# [3 6]] 3 数学运算：1234567891011121314151617181920212223# 基本运算a = np.array([1, 2, 3])b = np.array([4, 5, 6])print(a + b) # [5 7 9]print(a - b) # [-3 -3 -3]print(a * b) # [4 10 18]print(a / b) # [0.25 0.4 0.5]print(a ** 2) # [1 4 9]# 矩阵运算a = np.array([[1, 2], [3, 4]])b = np.array([[5, 6], [7, 8]])print(np.dot(a, b)) # 矩阵乘法# [[19 22]# [43 50]]# 统计函数print(np.mean(a)) # 2.5print(np.max(a)) # 4print(np.min(a)) # 1print(np.sum(a)) # 10 4 随机数生成12345678# 生成随机数random_array = np.random.random((2, 3)) # 2x3的均匀分布随机数数组# 生成指定范围的均匀分布随机数uniform_array = np.random.uniform(-1, 1, size=(2, 3))# 生成正态分布随机数normal_array = np.random.normal(0, 1, size=(2, 3)) 5 数组排序和条件过滤123456789a = np.array([3, 1, 4, 2])# 排序print(np.sort(a)) # [1 2 3 4]# 条件过滤mask = a &gt; 2print(mask) # [True False True False]print(a[mask]) # [3 4]","path":"2025/04/22/numpy使用方法/","date":"04-22","excerpt":"","tags":[]},{"title":"","text":"","path":"2025/03/21/STL使用手册/","date":"03-21","excerpt":"","tags":[]},{"title":"","text":"docker的英伟达cuda仓库 nvidia&#x2F;cuda - Docker Image | Docker Hub 生成一个包含cuda同时支持x11的ubuntu2004 1docker pull nvidia/cuda:12.8.0-cudnn-devel-ubuntu20.04 &amp;&amp; docker run -itd --gpus all -v /tmp/.X11-unix:/tmp/.X11-unix -e DISPLAY=$DISPLAY --name DexMV nvidia/cuda:12.8.0-cudnn-devel-ubuntu20.04 bash docker-compose 123docker-compose builddocker-compose up -ddocker-compose exec mujoco-cuda bash dockerfile run 1234567docker run -itd \\ --gpus all \\ -v &quot;/c/Users/yulong wang/OneDrive/Desktop/MyDockerfile/workspace:/workspace&quot; \\ -v /tmp/.X11-unix:/tmp/.X11-unix \\ -e DISPLAY=$DISPLAY \\ --name DexMV \\ dexmv-image 打开docker交互终端 docker exec -it DexMV &#x2F;bin&#x2F;bash pip换源清华大学 1mkdir -p ~/.pip &amp;&amp; echo -e &quot;[global]\\nindex-url = https://pypi.tuna.tsinghua.edu.cn/simple\\n[install]\\ntrusted-host = pypi.tuna.tsinghua.edu.cn&quot; &gt; ~/.pip/pip.conf ubuntu 20.04换源中科大 1sudo sed -i &#x27;s@//.*archive.ubuntu.com@//mirrors.ustc.edu.cn@g&#x27; /etc/apt/sources.list 123python3 -m venv myenv # 创建虚拟环境source myenv/bin/activate # 激活（Linux/macOS）deactivate #退出虚拟环境 conda源更换~&#x2F;.condarc文件 channels: https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free defaultsshow_channel_urls: true Ubuntu换源中科大 123456789101112131415sudo cp /etc/apt/sources.list /etc/apt/sources.list.baksudo sh -c &#x27;echo &quot;# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.ustc.edu.cn/ubuntu/ focal main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ focal-updates main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-updates main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ focal-backports main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-backports main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ focal-security main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.ustc.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse&quot; &gt; /etc/apt/sources.list&#x27; &amp;&amp; sudo apt update git换源中科大 1git config --global url.&quot;https://mirrors.ustc.edu.cn/git/&quot;.insteadOf https://github.com/ 查看全局配置是否生效： 1git config --global --get-regexp url\\..*\\.insteadOf docker启动挂载git ssh密钥 1docker run -it -v ~/.ssh:/root/.ssh your_image 逐行安装requirement while read -r package; do pip install –no-cache-dir “$package”done &lt; requirements.txt Miniconda 常用命令 功能 命令 创建环境 conda create -n 环境名 python=版本 激活环境 conda activate 环境名 退出环境 conda deactivate 删除环境 conda remove -n 环境名 --all 列出所有环境 conda env list","path":"2025/02/24/docker/","date":"02-24","excerpt":"","tags":[]},{"title":"ROS","text":"基础算法1. Topic话题和Message消息1.2 Publish发布者​ 1.召唤ROS大管家rospy​ 2.向ROS大管家申请初始化节点​ 3.告诉ROS大管家rospy需要发布的话题名称，并向他索要能够发送消息包的发布对象pub。​ 4.开启一个whie循环，不停的使用pub对象发布消息包。 12345678910111213141516171819#!/usr/bin/env python3# coding=utf-8import rospyfrom std_msgs.msg import Stringif __name__==&quot;__main__&quot;: rospy.init_node(&quot;chao_node&quot;); rospy.logwarn(&quot;我的枪去而复返，你的生命有去无回&quot;);pub = rospy.Publisher(&quot;kuai_shang_che_kai_hei_qun&quot;,String,queue_size=10)rate = rospy.Rate(10)while not rospy.is_shutdown(): rospy.loginfo(&quot;我要开始刷屏了&quot;); msg = String() msg.data = &quot;国服马超带飞&quot; pub.publish(msg) rate.sleep() 1.2 Subscriber订阅者​ 1.召唤ROS大管家rospy​ 2.向ROS大管家rospy申请初始化节点。​ 3.构建一个回调函数，用于处理从话题中接收到的消息包数据​ 4.告诉ROS大管家 rospy需要订阅的话题名称，并设置接收消息包的回调函数。​ 5.调用ROS的spin()函数。 12345678910111213141516171819#!/usr/bin/env python3# coding=utf-8import rospyfrom std_msgs.msg import Stringdef chao_callback(msg): rospy.loginfo(msg.data)def yao_callback(msg): rospy.logwarn(msg.data)if __name__ == &quot;__main__&quot;: rospy.init_node(&quot;ma_node&quot;) sub = rospy.Subscriber(&quot;kuai_shang_che_kai_hei_qun&quot;,String,chao_callback,queue_size=10) sub_2 = rospy.Subscriber(&quot;gie_gie_dai_wo&quot;,String,yao_callback,queue_size=10) rospy.spin() 1.3 launch启动多个ROS节点格式：![image-20241018142606686](C:\\Users\\yulong wang\\AppData\\Roaming\\Typora\\typora-user-images\\image-20241018142606686.png) 12345678&lt;launch&gt;&lt;node pkg=&quot;ssr_pkg&quot; type=&quot;chao_node.py&quot; name=&quot;chao_node&quot;/&gt;&lt;node pkg=&quot;ssr_pkg&quot; type=&quot;yao_node.py&quot; name=&quot;yao_node&quot;/&gt;&lt;node pkg=&quot;atr_pkg&quot; type=&quot;ma_node.py&quot; name=&quot;ma_node launch-prefix=&quot;gnome-terminal -e&quot;/&gt; &lt;!-- launch-prefix=&quot;gnome-terminal -e ：单独运行在一个terminal--&gt; &lt;/launch&gt; 2. 标准消息包std_msgs![image-20241017195340608](C:\\Users\\yulong wang\\AppData\\Roaming\\Typora\\typora-user-images\\image-20241017195340608.png) 结构体类型： ​ ColorRGBA（表示像素） ​ Duration&#x2F;Time （相对时间&#x2F;绝对时间） ​ Header（时间戳和坐标） ​ MultiArrayDImension&#x2F;MultiArrayLayout（描述数组内容） 3. 常用消息包common_msgs![image-20241017200414874](C:\\Users\\yulong wang\\AppData\\Roaming\\Typora\\typora-user-images\\image-20241017200414874.png) ​ 常用消息包：geometry_msgs&#x2F;sensor_msgs 3.1 几何消息包geometry_msgs![image-20241017200601343](C:\\Users\\yulong wang\\AppData\\Roaming\\Typora\\typora-user-images\\image-20241017200601343.png) 3.2 传感器消息包sensor_msgs![image-20241017200628634](C:\\Users\\yulong wang\\AppData\\Roaming\\Typora\\typora-user-images\\image-20241017200628634.png) 3.3 自定义消息类型生成自定义消息的步骤： 创建新软件包，依赖项message_generation、message_runtime 软件包添加msg目录，新建自定义消息文件，以.msg结尾。 在CMakeLists.txt中，将新建的.msg文件加入add message_files() 在CMakeLists.txt中去掉generate_messages()注释符号，将依赖的其他消息包名称添加进去。 在CMakeLists.txt中，将message_runtime 加入 catkin_package()的CATKIN DEPENDS。 在package.xml中，将message_generation、message_runtime加入和 编译软件包，生成新的自定义消息类型 3.4 自定义消息类型的应用 在节点代码中，先 import 新定义的消息类型。 在发布或订阅话题的时候，将话题中的消息类型设置为新的消息类型。 按照新的消息结构，对消息包进行赋值发送或读取解析。 在CMakeLists.txt文件的find_package()中，添加新消息包名称作为依赖项。 在package.xml中，将新消息包添加到和中去。 重新编译，确保全歼包进入ROS的包列表。 4.栅格地图4.1栅格地图格式 地图数据格式 ![image-20241018164710650](C:\\Users\\yulong wang\\AppData\\Roaming\\Typora\\typora-user-images\\image-20241018164710650.png) 地图描述信息 ![image-20241018164834735](C:\\Users\\yulong wang\\AppData\\Roaming\\Typora\\typora-user-images\\image-20241018164834735.png) 4.2发布地图 构建一个软件包map_pkg，依赖项里加上nav_msgs 编译软件包，让其进入ROS的包列表。 在map_pkg里创建一个节点map_pub_node.py。 在节点中发布话题&#x2F;map，消息类型为OccupancyGrid。 构建一个OccupancyGrid地图消息包，并对其进行赋值。 将地图消息包发送到话题&#x2F;map。 为节点map_pub_node.py添加可执行权限 运行map_pub_node.py节点 启动RViz，订阅话题&#x2F;map，显示地图 5.slam​ 同步定位与建图（Simultaneous Localization and Mapping，简称SLAM）问题可以描述为：机器人在未知环境中从一个未知位置开始移动,在移动过程中根据位置和地图进行自身定位，同时在自身定位的基础上建造增量式地图，实现机器人的自主定位和导航。 5.1Hector_Mapping6.ROS的TF系统​ 地图坐标系（&#x2F;map）：原点在机器人建图的初始位置，坐标轴方向遵循ROS的右手法则 ​ 机器人坐标系（&#x2F;base_footprint）：原点在机器人底盘中心位置，坐标轴方向遵循ROS的右手法则 ​ 地图坐标系作为父坐标系，机器人坐标系为子坐标系。 ​ TF（Transform）：用于描述子坐标系关于父坐标系的位置和角度偏移量","path":"2024/10/30/ROS/","date":"10-30","excerpt":"","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://niconekomimi.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"python","slug":"python","permalink":"https://niconekomimi.github.io/tags/python/"}]},{"title":"算法基础课","text":"一、基础算法1 高精度1.1 高精度加法(不带负号)1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string s1, s2; int a1[210] = &#123; 0 &#125;; int a2[210] = &#123; 0 &#125;; int a3[210] = &#123; 0 &#125;; cin &gt;&gt; s1; //getline(cin, s1); cin &gt;&gt; s2; //getline(cin, s2); //分别将数字转置放入数组中 for (int i = 0; i &lt; s1.size(); i++) a1[s1.size() - i - 1] = s1[i] - &#x27;0&#x27;; for (int i = 0; i &lt; s2.size(); i++) a2[s2.size() - i - 1] = s2[i] - &#x27;0&#x27;; //找到最长的数字 int len = s1.size(); if (s2.size() &gt; s1.size()) len = s2.size(); //相加每一位，并通过判断进行进位 for (int i = 0; i &lt; len; i++) a3[i] = a1[i] + a2[i]; for (int i = 0; i &lt; len; i++) &#123; if (a3[i] &gt; 10) &#123; a3[i + 1] = a3[i + 1] + a3[i] / 10; a3[i] = a3[i] % 10; &#125; &#125; //判断最后一位是否进位，若进位，则相加后的数字长度加1 if (a3[len] != 0) len++; //输出每一位 for (int i = len - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; a3[i]; &#125;&#125; 1.2 高精度减法(不带负号)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string s1, s2; int a1[210] = &#123; 0 &#125;; int a2[210] = &#123; 0 &#125;; int a3[210] = &#123; 0 &#125;; cin &gt;&gt; s1; //getline(cin, s1); cin &gt;&gt; s2; //getline(cin, s2); char flag = &#x27;+&#x27;; //判断结果是否为负数，然后将较大的数字放在是s1中 if (s1.size() &lt; s2.size() || s1.size() == s2.size() &amp;&amp; s1 &lt; s2)&#123; swap(s1, s2); flag = &#x27;-&#x27;; &#125; //分别将数字转置放入数组种 for (int i = 0; i &lt; s1.size(); i++) a1[s1.size() - i - 1] = s1[i] - &#x27;0&#x27;; for (int i = 0; i &lt; s2.size(); i++) a2[s2.size() - i - 1] = s2[i] - &#x27;0&#x27;; //将每位相减，不够就向上位借一位 for (int i = 0; i &lt; s1.size();i++) &#123; if (a1[i] &lt; a2[i]) &#123; a1[i] = a1[i] + 10; a1[i + 1] = a1[i + 1] - 1; &#125; a3[i] = a1[i] - a2[i]; &#125; //如果结果是负数，则先输出负号 if (flag == &#x27;-&#x27;) &#123; cout &lt;&lt; flag; &#125; //寻找第一位数的位置，当 int index = 0; for (int i = s1.size()-1; i &gt;= 0; i--) &#123; if (a3[i] != 0) &#123; index = i; break; &#125; &#125; //输出结果 for (int i = index; i &gt;= 0; i--) &#123; cout &lt;&lt; a3[i]; &#125; return 0;&#125; 1.3 高精度乘法(不带负号)123456789101112131415161718192021222324252627282930string mul(string s1, string s2) &#123; string s3 = &quot;&quot;; reverse(s1.begin(), s1.end()); reverse(s2.begin(), s2.end()); int a1[4000] = &#123; 0 &#125;; int a2[4000] = &#123; 0 &#125;; for (int i = 0; i &lt; s1.size(); i++) a1[i] = s1[i] - &#x27;0&#x27;; for (int i = 0; i &lt; s2.size(); i++) a2[i] = s2[i] - &#x27;0&#x27;; for (int i = 0; i &lt; s1.size(); i++) &#123; string temp = &quot;&quot;; int temparr[4000] = &#123; 0 &#125;; for (int j = 0; j &lt; s2.size(); j++) temparr[j + i] = a1[i] * a2[j]; for (int j = i; j &lt; s2.size() + i; j++) &#123; if (temparr[j] &gt;= 10) &#123; temparr[j + 1] = temparr[j + 1] + temparr[j] / 10; temparr[j] = temparr[j] % 10; &#125; &#125; int len = 0; for (int i = 3999; i &gt;= 0; i--) if (temparr[i] != 0) &#123; len = i + 1; break; &#125; for (int i = 0; i &lt; len; i++) temp.push_back(temparr[i] + &#x27;0&#x27;); reverse(temp.begin(), temp.end()); s3 = add(s3, temp); &#125; return s3;&#125; 2 排序算法2.1快速排序 确定分界点：q[1]、q[(r)&#x2F;2]、q[r]、随机 调整区间 递归处理左右两端 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void quick_Sort(vector&lt;int&gt;&amp; num, int l, int r) &#123; int i = l - 1, j = r + 1; //超边界，因为后续处理，每次都会先执行进位； int x = num[(l + r) / 2]; //终止递归的条件 if (l &gt;= r) return; while (i &lt; j) &#123; do i++; while (num[i] &lt; x); do j--; while (num[j] &gt; x); //若不先进位，出现两个相同数交换时，会无限循环 if (i &lt; j) swap(num[i], num[j]); &#125; quickSort(num, l, j); quickSort(num, j + 1, r);&#125;int main()&#123; vector&lt;int&gt; num = &#123; 7,9,6,8,4,4,15,32,88,76,29,42,10,1,0,55,69,93 &#125;; quick_Sort(num, 0, num.size() - 1); for (int x : num) cout &lt;&lt; x &lt;&lt; &quot; &quot;;&#125; 2.2 归并排序12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void merge_sort(vector&lt;int&gt; &amp;num, int l, int r) &#123; if (l &gt;= r) return; //一个元素天然有序； int m = (l + r) / 2; merge_sort(num, l , m); merge_sort(num, m+1, r); //每次均匀划分取中间坐标 vector&lt;int&gt; t;//存储合并后的结果 //合并左右两数组 int i = l, j = m + 1; while (i &lt;= m &amp;&amp; j &lt;= r) &#123; if (num[i] &lt; num[j]) t.push_back(num[i++]); else t.push_back(num[j++]); &#125; while (i &lt;= m) t.push_back(num[i++]); while (j &lt;= r) t.push_back(num[j++]); for (int i = l, j = 0; i &lt;= r; i++, j++)&#123; num[i] = t[j]; &#125;&#125;int main()&#123; vector&lt;int&gt; num = &#123; 7,9,6,8,4,4,15,32,88,76,29,42,10,1,0,55,69,93 &#125;; merge_sort(num, 0, num.size() - 1); for (int x : num) cout &lt;&lt; x &lt;&lt; &quot; &quot;;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int n;int q[N], tmp[N];void merge_sort(int q[], int l, int r) //l代表左边界，r代表右边界&#123; if (l &gt;= r) return; int mid = l + r &gt;&gt; 1; //左右边界相加，右移一位相当于除以2，得到中间位置 merge_sort(q, l, mid), merge_sort(q, mid + 1, r); //二分之后将左右数组递归 //将两个有序的数组归并在一起 int k = 0, i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (q[i] &lt;= q[j]) tmp[k++] = q[i++]; else tmp[k++] = q[j++]; &#125; while (i &lt;= mid) tmp[k++] = q[i++]; while (j &lt;= r) tmp[k++] = q[j++]; //将临时数组放回q[] for (i = l, j = 0; i &lt;= r; i++, j++) q[i] = tmp[j];&#125;int main()&#123; scanf_s(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) scanf_s(&quot;%d&quot;, &amp;q[i]); merge_sort(q, 0, n - 1); for (int i = 0; i &lt; n; i++) printf(&quot;%d&quot;, q[i]); return 0;&#125; 整数二分模板 12345678910111213141516171819202122232425//区间[l,r]被划分为[l,mid-1]和[mid,r]时使用int bsearch_1(int l,int r)&#123; while(l&lt;r) &#123; int mid=(l+r+1)&gt;&gt;1; //不加1的话会死循环 //相当于/2，但是&gt;&gt;是向下取整,/2是向0取整 if (check(mid)) l=mid; else r=mid+1; &#125; return l;&#125;//区间[l,r]划分为[l,mid]和[mid+1,r]时使用int bsearch(int l,int r)&#123; while(l&lt;r) &#123; int mid=(l+r)&gt;&gt;1; //相当于/2，但是&gt;&gt;是向下取整,/2是向0取整 if(check(mid)) r=mid; else l=mid+1; &#125; return l;&#125; 3 枚举3.1 利用二进制掩码解决n数选k数的问题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;using namespace std;//计算二进制数的1个数int count_bits(int num) &#123; int count = 0; while (num) &#123; count += num &amp; 1; //1相当于0b00...001，和二进制数与操作可以算出最低为是否为1 num &gt;&gt;= 1; //将数字又移一位 &#125; return count;&#125;//判断是否为素数的算法bool isSu(int x) &#123; if (x &lt;= 1) return false; if (x == 2) return true; if (x % 2 == 0) return false; for (int i = 3; i * i &lt;= x; i += 2) if (x % i == 0) return false; return true;&#125;int n, k, ans;int a[40];int main()&#123; cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; //生成掩码mask，持续+1，掩码长度应该小于总数字长度+1； for (int mask = 0; mask &lt; (1 &lt;&lt; n); mask++)&#123; if (count_bits(mask) != k) //掩码1的个数为k时继续执行 continue; int sum = 0; for (int i = 0; i &lt; n; i++) if (mask &amp; (1 &lt;&lt; i)) //掩码与（1&lt;&lt;i）相与，可以得到哪一位是1 //（1&lt;&lt;i）相当于将1向左移动i位得到 0b100... sum += a[i]; if (isSu(sum)) ans++; &#125; cout &lt;&lt; ans; return 0;&#125;","path":"2024/10/30/算法基础课/","date":"10-30","excerpt":"","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://niconekomimi.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"c/c++","slug":"c-c","permalink":"https://niconekomimi.github.io/tags/c-c/"}]},{"title":"JavaScript","text":"1.什么是JavaScriptjavascript是一门世界上最流行的脚本语言 &#x3D;&#x3D;一个合格的后端程序员必须精通JavaScript&#x3D;&#x3D; 2.快速入门2.1引入JavaScript1.内部标签 123&lt;script&gt; //.....&lt;/script&gt; 2.外部引入 abc.js 1//... test.html 1&lt;script src=&quot;abc.js&quot;&gt;&lt;/script&gt; 123456789101112&lt;script&gt; alert(&quot;hello world&quot;);&lt;/script&gt;&lt;!--外部引入--&gt;&lt;!--注意：script标签必须成队出现--&gt;&lt;script src=&quot;js/yl.js&quot;&gt;&lt;/script&gt;&lt;!--type 默认为JavaScript--&gt;&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 2.2基本语法入门123456789101112131415&lt;script&gt; // 1.定义变量 变量类型 变量名=变量值； var num =3; var num1 =20; var num2 = num1*num+num; // 2.条件控制 if (num&gt;60 &amp;&amp; num&lt;80)&#123; alert(&quot;true&quot;); &#125; else&#123; alert(&quot;false&quot;); &#125; //console.log()在浏览器的控制台打印变量！ System.out.println();&lt;/script&gt; 2.3数据类型数字、文本、图形、音频、视频…… &#x3D;&#x3D;变量&#x3D;&#x3D; 1var xxx = &quot;xxx&quot; &#x3D;&#x3D;number&#x3D;&#x3D; js不区分小数和整数，Number 123456123//整数123.1//浮点数1.123の//科学计数法-99//负数NaN//not a numberInfinity //表示无限大 &#x3D;&#x3D;字符串&#x3D;&#x3D; ‘abc’ “abc” &#x3D;&#x3D;布尔值&#x3D;&#x3D; true，false &#x3D;&#x3D;逻辑运算&#x3D;&#x3D; 123&amp;&amp; 与|| 或! 非 &#x3D;&#x3D;比较运算符&#x3D;&#x3D;！！！重要！ 123===等于 （类型不一样，值一样，也会判断为true）===绝对等于 （类型一样，值一样，结果为true） 这是js的一个缺陷，坚持不要使用&#x3D;&#x3D;比较 须知： NaN&#x3D;&#x3D;&#x3D;NaN,这个与所有的数值都不想等，包括自己 自能通过isNaN来判断这个数是否为NaN 浮点数问题 1console.log(1/3===(1-2/3)) 尽量避免使用浮点数进行运算，存在精度问题 1math.abs(1/3-(1-2/3))&lt;0.000000001 &#x3D;&#x3D;null和undefined&#x3D;&#x3D; null空 undefined未定义 &#x3D;&#x3D;数组&#x3D;&#x3D; 1234//保证代码可读性，尽量使用[]var arr = [1,2,3,&#x27;hello&#x27;,null];new Array(1,2,3,&#x27;hello&#x27;,null); &#x3D;&#x3D;对象&#x3D;&#x3D; 12345var person =&#123; name:&quot;tianlei&quot;, age:3, tagp:[&#x27;leilei&#x27;,&#x27;tianlei&#x27;]&#125; 取对象的值 1234person.name&gt; &quot;yulong&quot;person.age&gt; 3 2.4严格检查模式123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!-- 前提：IEDA需要设置支持ES6语法 `user strict`;严格检查模式，预防js随机性导致的一些问题 必须写在第一行 局部变量都去用let定义 --&gt; &lt;script &gt; `use strict`; //全局变量 let i=1; //es6 let &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 3.数据类型3.1字符串1.字符串用单引号或双引号包裹 2.注意转义字符\\ 12345\\&#x27;\\n\\t \\u4e2d \\u#### Unicode字符“\\x41” Ascll字符 3.多行字符串编写 12345//tab 上面的引号var msg = `好家伙这是tab引号不是单引号` 4.模板字符串 12345//tab 上面的引号let name =&quot;王玉龙&quot;;let age = &quot;22&quot;let b = `你好啊，$&#123;name&#125;//$用于引用其它元素 5.字符串长度 1str.length 6.字符串的可变性，不可变 7.大小写转换 123//注意这里是方法，不是属性student.toUpperCase()student.toLowerCase() 8.student.indexOf(“t”) 9.substring 12student.substring(1)//1到最后一个字符student.substring(2,4)//2到4个字符串 3.2数组Array可以包含任意的数据类型 1var arr =[1,2,3,4,5,6] 1.长度 1arr.length 注意：加入给arr.length赋值，数组大小就会发生变化，如果赋值过小，元素就会丢失 2.indexOf,通过元素获得下标索引 12arr.indexof(2)1 3.**slice()**截取Array的一部分，返回一个新的数组，类似于string中的substring 4.push(),pop() 12push:压入到尾部pop：弹出尾部的一个元素 5.unshift(),shift()头部 12unshift:压入到头部shift：弹出头部的一个元素 6.排序sort（） 1arr.sort() 7.元素反转 1arr.reverse() 8.concat() 1arr.concat([1,2,3]) 注意：concat()并没有修改素组，只是会返回一个新的数组 9.连接符join 打印拼接素组，使用指定的字符串链接 1arr.join(&#x27;-&#x27;) 10.多维数组 1arr = [[1,2][3,4],[&quot;5&quot;,&quot;6&quot;]] 3.3对象若干键值对 123456789101112131415var 对象名 =&#123; 属性名:属性值, 属性名:属性值, 属性名:属性值&#125;//定义了一个person对象，它有四个属性！&lt;script&gt; var person = &#123; name : &quot;yulong&quot;, age: 3, email: &quot;673269043@qq.com&quot;, score: 0 &#125;&lt;/script&gt; js中对象，{……}表示一个对象，键值对描述属性 xxxx: xxxx，多个属性用逗号隔开，最后一个属性不加逗号！ JavaScript中的所有的键都是字符串，值是任意对象！ 1.对象赋值 1234person.name =&quot;yulong&quot;&quot;yulong&quot;person.name&quot;qinjiang&quot; 2.使用一个不存在的对象属性，不会报错！undefined 12person.hahaundefined 3.动态的删减属性，通过delete删除对象的属性 123delete person.nametrueperson 4.动态的添加，直接给新的属性添加值即可 123person.haha = &quot;haha&quot;&quot;haha&quot;person 5.判断属性值是某在这个对象中！ xxx in xxx 12345&#x27;age&#x27; in persontrue//继承父属性，&#x27;toString&#x27;为父元素属性值&#x27;toString&#x27; in persontrue 6.判断一个属性是否是这个对象自身拥有的 hasOwnProperty() 1234person.hasOwnProperty(&#x27;age&#x27;)trueperson.hasOwnProperty(&#x27;toString&#x27;)false 3.4流程控制if判断 12345678var age = 3;if (age &gt;3)&#123; ralert(false);&#125;else if (2&lt;age&lt;3)&#123; alert(&#x27;a&#x27;);&#125; else&#123; alert(true);&#125; while循环 1234while(age &lt;100)&#123; age =age +1; console.log(age)&#125; for循环 123for (let i =0;i&lt;40;i++)&#123; console.log(i);&#125; forEach循环 5.1引入的 123456var age =[12,14,1,6,8,17,10,15,20]//函数age.forEach(function (value)&#123; console.log(value)&#125;) for…in 123for (var num in age)&#123; console.log(age[num])&#125; 3.5 Map 和 SetMap: 123456//ES6 Map//学生的成绩，学生的名字var map =new Map([[&#x27;tom&#x27;,90],[&#x27;jorn&#x27;,100],[&#x27;jack&#x27;,85]]);var name =map.get(&#x27;tom&#x27;);//通过key获得valuemap.set(&#x27;admin&#x27;,123456);//新增一个元素map.delete(&quot;tom&quot;);//删除 Set: 无需不重复的集合 1234var set =new Set([3,5,1,2,1]);set.add(2); //添加set.delete(1); //删除console.log(set.has(3)); //是否包含某个元素 3.6 iterator es6新特性 遍历数组 12345//通过for of/ for in打印数组下标var arr = [3,4,5]for (var x of arr)&#123; console.log(x) &#125; 遍历map 1234var map = new Map([[&#x27;tom&#x27;,90],[&#x27;jorn&#x27;,100],[&#x27;jack&#x27;,85]]);for(let x of map)&#123; console.log(x)&#125; 遍历set 1234var set =new Set([3,5,1,2,1]);for(let x of set)&#123; console.log(x)&#125; 4.函数及面向对象4.1函数定义及变量作用域","path":"2022/04/24/JavaScript/","date":"04-24","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://niconekomimi.github.io/tags/JavaScript/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://niconekomimi.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"CSS笔记","text":"1.CSS基本格式语法：选择器{ 声明1; 声明2; 声明3;} 2.CSS的三种导入方式 直接标签加入style属性；（行内样式） 1&lt;h1 style=&quot;color: red&quot;&gt;我是标题&lt;/h1&gt; 用写入；（内部样式） 12345&lt;style&gt; h1&#123; color: #ff0000; &#125;&lt;/style&gt; 创建一个css文件，用于在html5文件中链接css文件；（外部样式） 1&lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt; &#x3D;&#x3D;优先级，就近原则，用离代码最近的样式&#x3D;&#x3D; 1234&lt;!--导入式--&gt; &lt;style&gt; @import &quot;css/style.css&quot;; &lt;/style&gt; 旧版2.1导入css方式 3.选择器 标签选择器：选择所有标签 标签{} 123456789h1&#123; /*标签选择器，会选择所有的h1标签*/ color: red; background: aqua; border-radius: 24px; &#125; &lt;h1&gt;一个标签&lt;/h1&gt;&lt;h1&gt;二个标题&lt;/h1&gt; 类选择器：选择一类标签 .class{} 1234567891011121314/*类选择器格式.class的名称&#123;&#125;好处可以多个标签归类，是同一个class*/.shiyigelei&#123; color: red;&#125;.shiergelei&#123; color: blueviolet;&#125;&lt;h1 class=&quot;shiyigelei&quot;&gt;标题1&lt;/h1&gt;&lt;h1 class=&quot;shiergelei&quot;&gt;标题2&lt;/h1&gt; id选择器：id全局唯一 #id{} 1234567891011121314/*id选择器:id必须保证全局唯一#id名称&#123;&#125;不遵循就近原则，固定id选择器&gt;class选择器&gt;标签选择器*/#dage&#123; color: blue;&#125;#xiaodi&#123; color: deeppink;&#125;&lt;h1 id=&quot;dage&quot;&gt;标题1&lt;/h1&gt;&lt;h1 id=&quot;xiaodi&quot;&gt;标题2&lt;/h1&gt; &#x3D;&#x3D;三种选择器不遵循就近原则，固定id选择器&gt;class选择器&gt;标签选择器&#x3D;&#x3D; 4.层次选择器 后代选择器 123body p&#123; background: red;&#125; 子选择器，选儿子辈 123body&gt;p&#123; background: deeppink;&#125; 相邻兄弟选择器,只有一个，相邻向下 123.active+p&#123; background: blueviolet; &#125; 4.通用选择器,当前选中元素所有向下的所有兄弟元素 123.active~p&#123; background: green;&#125; 5.结构伪类选择器伪类：条件 1234567891011121314151617181920/*ul的第一个子元素*/ul li:first-child&#123; background: red;&#125;/*ul的最后一个元素*/ul li:last-child&#123; background: green;&#125;/*选中p1：定位到父元素，选择当前的第一个元素选择当前p元素的父级元素，选中父级元素的第一个，并且是当前元素才生效*/p:nth-child(1)&#123; background: blueviolet;&#125;/*选中父元素下的p元素的第二个*/p:nth-of-type(1)&#123; background: deeppink;&#125; &#x3D;&#x3D;p:nth-child(x)与p:nth-of-type(x)的区别：第一个是找父元素下第x个元素是否为p，若为p则生效；第二个是找父元素下第x个p元素&#x3D;&#x3D; 6.属性选择器（常用）通过属性来查找元素 标签[属性名&#x3D;属性值]{}&#x3D; 代表绝对等于*&#x3D;代表包含这个元素^&#x3D;以这个开头$&#x3D;以这个结尾 7.美化网页元素1.span标签，需要突出的字用span标签套起来 123456789101112131415&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #title&#123; font-size: 50px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;欢迎学习 &lt;span id=&quot;title&quot;&gt;JAVA&lt;/span&gt;&lt;/body&gt; font-size:字体大小font-family:字体font-weight:字体粗细color:字体颜色 123456789101112131415&lt;style&gt; #title&#123; font-size: 50px; &#125; body&#123; font-family: 宋体,&quot;Times New Roman&quot;; color: darksalmon; &#125; h1&#123; font-size: 50px; &#125; .p1&#123; font-weight: bold; &#125;&lt;/style&gt; 2.阴影text-shadow:阴影颜色，水平便宜，垂直便宜，阴影半径 1text-shadow: #3cc7f5 1px 10px 10px; 3.超链接伪类 123456789/*鼠标悬浮效果*/a:hover&#123; color: burlywood; font-size: 20px;&#125;/*鼠标按住效果*/a:active&#123; color: green;&#125; 4.列表 1234567891011121314151617181920212223242526272829#nav&#123; width: 280px; background: whitesmoke;&#125;.title&#123; font-size: 18px; font-weight: bold; text-indent: 1em; line-height: 35px; background: red;&#125;/*ul li 选中全部ul li*/ul li&#123; height: 30px; list-style: none; text-indent: 5px;&#125;ul&#123; background: whitesmoke;&#125;a&#123; text-decoration: none; //去掉超链接下划线 font-size: 14px; color: black;&#125;a:hover&#123; color: orange; text-decoration: underline;&#125; 5.背景 background-repeat:设置背景平铺 12345678910111213141516div&#123; width: 1000px; height: 2000px; border: 1px solid red; background-image: url(&quot;image/dc3699773912b31b88852444e120.png&quot;);&#125;/*background-repeat默认不平铺，repeat-x水平平铺，repeat-y竖直平铺*/.div1&#123; background-repeat: repeat-x;&#125;.div2&#123; background-repeat: repeat-y;&#125;.div3&#123; background-repeat: no-repeat;&#125; 6.渐变渐变色网站https://www.grabient.com/ 12background-color: #D9AFD9;background-image: linear-gradient(100deg, #D9AFD9 0%, #97D9E1 100%); 8.盒子模型 margin：外边距 从左往右 上左下右 margin: 0 margin: 0 1px margin: 0 1px 2px 3px margin: 0 1px 2px 3px 4px padding：内边距（与外边距相同） border：边框 ​ border:粗细，样式，颜色 9.圆角边框border-radius：设置边框的角 1234567891011&lt;!--左上 右上 右下 左下--&gt;&lt;style&gt; div&#123; width: 100px; height: 100px; border: 10px solid red; border-radius: 50px 20px 10px 0px; &#125;&lt;/style&gt; 10.阴影1box-shadow: 10px 10px 100px yellow; 右偏移 下便宜 阴影宽度 颜色 11.浮动标准文档：左边为标准文档格式 块级元素：独占一行 1h1~h6 p div 列表 ... 行内元素：不独占一行 1span a img strong ... 行内元素可以被包含在块级元素中，反之，则不可以~ display：block 块元素inline 行内元素inline-block 是块元素，但是也可以内联到一行none 1234567891011121314&lt;style&gt; div&#123; width: 100px; height: 100px; border: 1px solid red; display: inline-block; &#125; span&#123; width: 100px; height: 100px; border: 1px solid green; display: inline-block; &#125;&lt;/style&gt; 也是一种行内元素摆列的方式，但一般用float float 1.左右浮动float 1234567891011121314151617181920212223242526272829303132div&#123; margin: 20px; padding: 10px;&#125;#father&#123; border: 1px red solid;&#125;/*solid 实线 dashed 虚线*/.layer01&#123; border: 1px black dashed; display: inline-block; float: left;&#125;.layer02&#123; border: 1px #97D9E1 dashed; display: inline-block; float: left;&#125;.layer03&#123; border: 1px #ff0000 dashed; display: inline-block; float: left;&#125;.layer04&#123; border: 1px green dashed; font-size: 12px; line-height: 23px; display: inline-block; float: left;&#125; 父级边框塌陷问题 clear 1234clear:right; 右侧不允许有浮动元素clear:left; 左侧不允许有浮动元素clear:both; 两侧不允许有浮动元素clear：none 解决方法： 1、增加父级元素的高度~ 1234#father&#123; border: 1px red solid; height: 800px;&#125; 2.增加一个空的div标签，清除浮动 123456&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;.clear&#123; clear： both; margin: 0; padding: 0;&#125; 3、overflow 1在父级元素中增加一个overflow: hidden 4、父类添加一个伪类：after 12345#father:after&#123; content: &#x27;&#x27;; display: block; clear: both;&#125; 小结： 1.浮动元素后面增加空div 简单，代码中尽量避免空div 2.设置父元素的高度 简单，元素假设有了固定高度，会被限制 3.overflow 简单，下拉的一些场景避免食用 4.父类添加一个伪类：alter（推荐） 写法稍微复杂，但没有副作用，推荐使用。 对比 display 方向不可控 float 浮动起来会脱离标准文档流 12.定位12.1相对定位1234567891011121314151617181920212223242526272829303132333435363738394041&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--相对定位 相对于原来的位置进行偏移 --&gt; &lt;style&gt; div&#123; margin: 10px; padding: 5px; font-size: 12px; line-height: 25px; &#125; #father&#123; border: 1px solid #666; &#125; #first&#123; border: 1px dashed #a31d30; background-color: #a31d4f; position: relative;/*相对定位，上下移动*/ top: -20px; left: 20px; &#125; #second&#123; border: 1px dashed #D9AFD9; background-color: #D9AFff; &#125; #third&#123; border: 1px dashed #66ccff; background-color: #66ccf0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;father&quot;&gt; &lt;div id=&quot;first&quot;&gt;第一个盒子&lt;/div&gt; &lt;div id=&quot;second&quot;&gt;第二个盒子&lt;/div&gt; &lt;div id=&quot;third&quot;&gt;第三个盒子&lt;/div&gt;&lt;/div&gt; 相对定位 position：relative; 相对于原来的位置，进行指定的偏移，相对定位的话，它任然在标准文档流中，原来的位置会被保留 1234top: -20px;left: 20px;bottom: -10px;right: 20px; 12.2绝对定位1position: absolute; 定位：基于xxx定位，上下左右~ 1.没有父级元素定位的前提下，相对于浏览器定位 2.假设父级元素存在定位。我们通常会相对于父级元素进行定位 相对于父级或浏览器的位置，进行指定的偏移，相对定位的话，它不在标准文档流中，原来的位置不会被保留 12.3 固定定位1position：fixed; 绝对定位与固定定位的区别： 绝对定位在对于浏览器定位时，位置固定在初始位置。 固定定位定位于浏览器特定位置，应用场景：返回顶部 12.4 z-index12345678910111213141516171819202122232425262728293031#content&#123; width: 300px; padding: 0px; margin: 0px; font-size: 12px; line-height: 25px; border: 1px red solid;&#125;ul,li&#123; padding: 0px; margin: 0px; list-style: none;&#125;/*父级元素相对定位*/#content ul&#123; position: relative;&#125;.tipText,.tipBg&#123; position: absolute; width: 300px; height: 25px; top: 188px;&#125;.tipText&#123; color: white; z-index: 1; /*图层层级*/&#125;.tipBg&#123; background: #000000; opacity: 0.5; /*背景透明度*/&#125; z-index：图层层级 opacity：为背景透明度 13.动画14.总结","path":"2022/04/15/CSS笔记/","date":"04-15","excerpt":"","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://niconekomimi.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"css","slug":"css","permalink":"https://niconekomimi.github.io/tags/css/"}]},{"title":"HTML5笔记","text":"文档结构123456789101112131415161718192021&lt;!doctype html&gt;&lt;!--以html5解析如下代码--&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;;&gt; &lt;meta name=keywords&quot; content=&quot;&quot;&gt;&lt;!--关键字--&gt; &lt;meta name=&quot;description&quot; content=&quot;&quot;&gt;&lt;!--网站描述内容--&gt; &lt;title&gt;网站&lt;/title&gt; &lt;!--设置一个小图标:--&gt; &lt;link rel=&quot;shortcut icon&quot; href=&quot;https://i0.hdslb.com/bfs/tag/b13be00a840ad1c60770b0d352b84daadff67e7c.jpg&quot; type=&quot;img/jpg&quot;&gt; &lt;style&gt; /*书写样式的部分*/ &lt;/style&gt; &lt;link rel=&quot;atylesheet&quot; href=&quot;style.css&quot;;&gt;&lt;!--用来引入外部样式文件--&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;//这是一个文本&lt;/p&gt;&lt;/body&gt;&lt;script&gt; //放脚本代码的地方&lt;/script&gt;&lt;/html&gt; 基本标签生成文档结构快捷键 输入!后按tab或HTML:5后按tab div：用于布局，将文本分层 hx：标题，从1级到6级12&lt;h1&gt;一级标签&lt;h1&gt;&lt;h2&gt;二级标签&lt;h2&gt; p：表示一个段落1&lt;p&gt; br：表示换行，将一段文字换行1&lt;br/&gt; hr：生成一条分割线 设置后的标签，分别为宽度、位置】颜色、高度12&lt;hr/&gt;&lt;hr width=&quot;80%&quot; align=&quot;center&quot; color=&quot;red&quot; height=&quot;2px&quot;&gt; 粗体斜体12粗体：&lt;strong&gt;i love you&lt;/strong&gt;斜体：&lt;em&gt;i love you&lt;/em&gt; 空格1&amp;nbsp 特殊符号：&amp;+各种代码 图片标签&#x3D;&#x3D;快速生成img标签（输入img+tab键）&#x3D;&#x3D; 1&lt;img src=&quot;../resourse/image/cover_1.jpg&quot; alt=&quot;星光咖啡厅与死亡之蝶&quot; title=&quot;悬停标签&quot; &gt; &#x3D;&#x3D;每个属性后面接着引号按空格会自动跳出可以设置的属性菜单&#x3D;&#x3D; 链接标签&#x3D;&#x3D;快速生成a链接（a+tab）&#x3D;&#x3D; href表示跳转到的页面target: 表示窗口在哪打开 _blank在一个新标签打开 _self 在自己的网页中打开 1&lt;a href=&quot;tab.html&quot; target=&quot;_blank&quot;&gt;tab&lt;/a&gt; 锚链接1.需要一个锚标签2.跳转到标记3.# 123&lt;a name=&quot;top&quot;&gt;顶部&lt;/a&gt;下方代码用于跳到顶部的标记top&lt;a href=&quot;#top&quot;&gt;回到顶部&lt;/a&gt; 邮件链接：mailto：+邮箱 1&lt;a href=&quot;mailto:673269043@qq.com&quot;&gt;点击联系邮箱&lt;/a&gt; 行内元素和块元素 块内元素无论内容多少，元素独占一行（比如p、h1-h6…） 行内元素内容撑开宽度，左右都是行内元素可以再排一行（a、strong、em…） 列表标签 有序列表（Ordered List） 1234&lt;ol&gt; &lt;li&gt;内容1&lt;/li&gt; &lt;li&gt;内容2&lt;/li&gt;&lt;/ol&gt; 无序列表（Unordered List） 1234&lt;ul&gt; &lt;li&gt;内容1&lt;/li&gt; &lt;li&gt;内容2&lt;/li&gt;&lt;/ul&gt; 自定义列表（definition lists） dl:标签dt:列表名称dd:列表内容 123456789&lt;dl&gt; &lt;dt&gt;标题1&lt;/dt&gt; &lt;dd&gt;内容1&lt;/dd&gt; &lt;dd&gt;内容2&lt;/dd&gt; &lt;dt&gt;标题2&lt;/dt&gt; &lt;dd&gt;内容1&lt;/dd&gt; &lt;dd&gt;内容2&lt;/dd&gt;&lt;/dl&gt; 表格表格（table）行 tr （table rows）列(表格中的单元格) td （table data cell） 123456789101112131415161718192021222324252627&lt;table border=&quot;1px&quot;&gt; &lt;tr&gt; &lt;!--跨列colspan--&gt; &lt;td colspan=&quot;4&quot;&gt;1-1&lt;/td&gt; &lt;!--第一个元素跨四列--&gt; &lt;/tr&gt; &lt;tr&gt; &lt;!--跨行 rowspan--&gt; &lt;td rowspan=&quot;2&quot;&gt;2-1&lt;/td&gt; &lt;!--2-1向下跨两行--&gt; &lt;td&gt;2-2&lt;/td&gt; &lt;td&gt;2-3&lt;/td&gt; &lt;td&gt;2-4&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3-1&lt;/td&gt; &lt;td&gt;3-2&lt;/td&gt; &lt;td&gt;3-3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;4-1&lt;/td&gt; &lt;td&gt;4-2&lt;/td&gt; &lt;td&gt;4-3&lt;/td&gt; &lt;td&gt;4-4&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 视频和音频 scr:资源路径 controls:控制条 autoplay:自动播放 123&lt;video src=&quot;../resourse/video/video.mp4&quot; controls autoplay&gt;&lt;/video&gt;&lt;audio src=&quot;../resourse/audio/米津玄師%20-%20Lemon.mp3&quot; controls&gt;&lt;/audio&gt; 页面结构1234567891011&lt;header&gt; 网页头部&lt;/header&gt;&lt;secter&gt; 网页主体&lt;/secter&gt;&lt;footer&gt; 网页脚部&lt;/footer&gt; header：标题头部区域内容 footer：标记脚部区域的内容 section：web页面中的一块独立区域 article：独立文章内容 aside：相关内容或应用 nav：导航类辅助内容 内联框架iframe：用于在页面嵌入网页等 嵌入跳转链接的方法 12&lt;iframe src=&quot;&quot; name=&quot;hello&quot; frameborder=&quot;0&quot; width=&quot;1000px&quot; height=&quot;800px&quot;&gt;&lt;/iframe&gt;&lt;a href=&quot;4.链接标签.html&quot;target=&quot;hello&quot;&gt;点击跳转&lt;/a&gt; &#x3D;&#x3D;与跳转到顶部方法类似，为给iframe一个name属性定义一个标签，然后再用a标签跳转&#x3D;&#x3D; 表单学习form标签action:表单提交的位置，可以是网站，也可以是一个请求处理method:post,get提交方式 get方式提交，我们可以在url中看到我们提交的信息，不安全但高效post比较安全，可传输大文件。 input type 用于设置表单的形式 12345678910111213&lt;form action=&quot;3.图像标签.html&quot;method=&quot;post&quot;&gt; &lt;!--文本输入框：input type=&quot;text&quot; value=&quot;666&quot; 默认初始值 maxlength=&quot;8&quot; 最长能写几个字符 size=&quot;30&quot; 文本框长度 --&gt; &lt;p&gt;名字：&lt;input type=&quot;text&quot;name=&quot;username&quot;&gt;&lt;/p&gt; &lt;!--文本输入框：input type=&quot;password&quot;--&gt; &lt;p&gt;密码：&lt;input type=&quot;password&quot;name=&quot;pwd&quot;&gt;&lt;/p&gt; &lt;/form&gt; 单选框标签 input type&#x3D;”radio” value:单选框的值 name:表示组，若无组或组不一样则可以将两个都选上 1234&lt;p&gt;性别： &lt;input type=&quot;radio&quot;value=&quot;boy&quot;name=&quot;sex&quot;&gt;男 &lt;input type=&quot;radio&quot;value=&quot;girl&quot;name=&quot;sex&quot;&gt;女&lt;/p&gt; 多选框标签input type&#x3D;”checkbox”checked 默认选择 1234567&lt;p&gt;爱好： &lt;input type=&quot;checkbox&quot;value=&quot;sleep&quot;name=&quot;hobby&quot;&gt;睡觉 &lt;input type=&quot;checkbox&quot;value=&quot;chat&quot;name=&quot;hobby&quot;&gt;聊天 &lt;input type=&quot;checkbox&quot;value=&quot;game&quot;name=&quot;hobby&quot;&gt;游戏 &lt;input type=&quot;checkbox&quot;value=&quot;code&quot;name=&quot;hobby&quot;&gt;敲代码 &lt;input type=&quot;checkbox&quot;value=&quot;eat&quot;name=&quot;hobby&quot;&gt;吃饭&lt;/p&gt; 按钮标签input type&#x3D;”button” 按钮input type&#x3D;”image” 图片按钮input type&#x3D;”submit” 提交按钮input type&#x3D;”reset” 重置 123456789&lt;p&gt;按钮： &lt;input type=&quot;button&quot;name=&quot;btn1&quot;value=&quot;点击变长&quot;&gt; &lt;input type=&quot;image&quot;src=&quot;../resourse/image/cover_1.jpg&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;submit&quot;&gt; &lt;input type=&quot;reset&quot;&gt; &lt;/p&gt; 文本域cols 行rows 列 123&lt;p&gt;反馈： &lt;textarea name=&quot;textarea&quot; id=&quot;&quot; cols=&quot;50&quot; rows=&quot;10&quot;&gt;文本内容&lt;/textarea&gt;&lt;/p&gt; 文件域input type&#x3D;”file” 1234&lt;p&gt; &lt;input type=&quot;file&quot; name=&quot;files&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;上传&quot; name=&quot;upload&quot;&gt;&lt;/p&gt; 邮件验证 123&lt;p&gt;邮箱： &lt;input type=&quot;email&quot; name=&quot;email&quot;&gt;&lt;/p&gt; URL 123&lt;p&gt;url： &lt;input type=&quot;url&quot; name=&quot;url&quot;&gt;&lt;/p&gt; 数字 123&lt;p&gt;商品数量： &lt;input type=&quot;number&quot; name=&quot;number&quot; max=&quot;100&quot; min=&quot;0&quot; step=&quot;1&quot;&gt;&lt;/p&gt; 滑块 123&lt;p&gt;音量： &lt;input type=&quot;range&quot;name=&quot;voice&quot; min=&quot;0&quot;max=&quot;100&quot;step=&quot;2&quot;&gt;&lt;/p&gt; 搜索框 123&lt;p&gt;搜索： &lt;input type=&quot;search&quot;name=&quot;search&quot;&gt;&lt;/p&gt; &#x3D;&#x3D;readonly只读disable禁止hidden隐藏&#x3D;&#x3D; 增强鼠标可用性 1234&lt;p&gt; &lt;label for=&quot;mark&quot;&gt;你点我试试&lt;/label&gt; &lt;input type=&quot;text&quot;id=&quot;mark&quot;&gt;&lt;/p&gt; &#x3D;&#x3D;&#x3D;&#x3D;提醒输入的东西 placeholder&#x3D;”请输入用户名”非空判断 required正则表达 pattern&#x3D;””&#x3D;&#x3D;","path":"2022/04/08/html5笔记/","date":"04-08","excerpt":"","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://niconekomimi.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"html5","slug":"html5","permalink":"https://niconekomimi.github.io/tags/html5/"}]}],"categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://niconekomimi.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"python","slug":"python","permalink":"https://niconekomimi.github.io/tags/python/"},{"name":"c/c++","slug":"c-c","permalink":"https://niconekomimi.github.io/tags/c-c/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://niconekomimi.github.io/tags/JavaScript/"},{"name":"css","slug":"css","permalink":"https://niconekomimi.github.io/tags/css/"},{"name":"html5","slug":"html5","permalink":"https://niconekomimi.github.io/tags/html5/"}]}